%
% hrvfreq - calculates freq domain HRV using FFT, AR, and Lomb-Scargle methods
%
%Usage:  output = hrvfreq(method, locs);
%        output = hrvfreq(method, locs, frange);
%        output = hrvfreq(method, locs, frange, resamp_fs);
%        output = hrvfreq(method, locs, frange, resamp_fs, arorder); only for AR-model
%
%Inputs:    'method', cell array of strings that defines the methods used to
%               calculate freqDomain. 'fft', 'ar', 'lomb'
%           'locs', QRS locations, 1D array of time of QRS location (s or ms)
%           'frange', Frequency range to calclate VLF, LF and HF. 2D
%                           array of Frequency ranges. Default value is [0.0033, 0.04;
%                                                                       0.04, 0.15;
%                                                                       0.15, 0.4];
%           'resamp_fs', resample rate (Hz). Default value is 4 Hz
%           'arorder', order of AR model. Defulat value is 35-th order
%Outputs:   output is a structure containg all HRV.
%           Output units include:
%               peakVLF, peakLF, peakHF: peak frequency of VLF, LF, HF (Hz)
%               TP, VLF, LF, HF: power of total, VLF, LF, HF (ms^2)
%               nLF,nHF: noimalized power of LF, HF (n.u.)
%               PSD, Power Spectral Density (ms^2/Hz)
%               f: frequency of PSD (Hz)
%
% Copyright (C) 2016, Hangsik Shin, hangsik.shin@gmail.com
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
function output = hrvfreq(varargin)

nVarargs = length(varargin);

% check number of input arguments
if nVarargs > 5 || nVarargs<2
    error('ERROR: check number of input arguments');
end

if length(varargin{2}) == 1
    error('ERROR: QRS location should be 1D array');
end

% SET DEFAULT
fHRV = [0.0033, 0.04; 0.04, 0.15; 0.15, 0.4];
ar_order = 35;
resamp_fs = 4;

if nVarargs > 2
    if sum( size(varargin{3}) == [3,2] )
        fHRV = varargin{3};
    else
        error('ERROR : fHRV shound be a 3 by 2 matrix which includes VLF, LF and HF range in row');
    end
end

if nVarargs > 3
    resamp_fs = varargin{4};
end

if nVarargs>4
    if strcmpi(varargin{1},'ar')
        ar_order = varargin{5};
    else
        error('ERROR: Read the Usage');
    end
end

if strcmpi(varargin{1},'fft')
    fhandle = @func_fft;
    opt1 = resamp_fs;
    opt2 = NaN;
elseif strcmpi(varargin{1},'ar')
    fhandle = @func_ar;
    opt1 = resamp_fs;
    opt2 = ar_order;
elseif strcmpi(varargin{1},'lomb')
    fhandle = @func_lomb;
    opt1 = varargin{2};
    opt2 = NaN;
else
    error('Method should be selected in the fft, ar, lomb');
end

% Check input scale
isMillisec(varargin{2});
% Preprocessing  
interval = preprocessing(varargin{1}, varargin{2}, resamp_fs);
% Call function for each method
[output.f, output.PSD] = fhandle(interval, opt1, opt2);
% Calculatin the Power
output = calcPower(output.f, output.PSD, fHRV);

end

function isMillisec(locs)
if mean(diff(locs))>10000
    error('Time of peaks position should be in second');
end
end

function output_interval = preprocessing(method, input_loc, resamp_fs)
% % TIME : ms
interp_fs = 1000;
% 
output_interval = round( 1000 * diff(input_loc) );    % ms
% interval_sec=output_interval;
% etopic_ind = (0.675*interval_sec(1:end-1)>interval_sec(2:end))|(1.245*interval_sec(1:end-1)<interval_sec(2:end));
% output_interval(etopic_ind) = [];
output_interval = (output_interval-mean(output_interval))/std(output_interval);
% 
% 
% input_loc(etopic_ind)= [];
input_loc = input_loc(2:end);

t=input_loc(1):1/interp_fs:input_loc(end);    % s

% 1-detrend
output_interval = detrend(output_interval);
output_interval = output_interval-mean(output_interval);
if ~strcmpi(method, 'lomb')
    % 2-interpolation
    output_interval = interp1(input_loc, output_interval, t,'linear');
    % 3-resampling
    output_interval = resample(output_interval,resamp_fs,interp_fs)';
end
% 4-windowing
output_interval = output_interval.*hann( length(output_interval) );
end

function [f, PSD] = func_fft(interval, resamp_fs, ~)
NFFT = length(interval);
xdft = fft(interval);
xdft = xdft(1:NFFT/2+1);
PSD = (1/(resamp_fs*NFFT)) * abs(xdft).^2;
PSD(2:end-1) = 2*PSD(2:end-1);
f = 0:resamp_fs/NFFT:resamp_fs/2;
end

function [f, PSD] = func_lomb(interval, locs,~ )
[PSD,f] = plomb(interval,locs(2:end));
end

function [f, PSD] = func_ar(interval, resamp_fs, ar_order)
NFFT = 2^nextpow2( length(interval) ); % Next power of 2 from length of y
[PSD,f] = pburg(interval, ar_order, NFFT, resamp_fs);
end

function output = calcPower(f, PSD, fHRV)
% interpolating frequency component
nf = f(1):1/1000:f(end);
PSD = interp1(f, PSD, nf);
f = nf;

indTP = f>0 & f<=0.4;
indVLF = fHRV(1,1)<=f & f<=fHRV(1,2);
indLF = fHRV(2,1)<=f & f<=fHRV(2,2);
indHF = fHRV(3,1)<=f & f<=fHRV(3,2);

output.TP = trapz( f(indTP),PSD(indTP) );
output.VLF = trapz( f(indVLF), PSD(indVLF) );
output.LF = trapz( f(indLF), PSD(indLF) );
output.HF = trapz( f(indHF), PSD(indHF) );
output.LHF = output.LF/output.HF;
output.nLF = output.LF/(output.TP-output.VLF);
output.nHF = output.HF/(output.TP-output.VLF);
output.f = f;
output.PSD = PSD;

[~,a] = max(PSD(indVLF)); output.peakVLF = f(a);
[~,a] = max(PSD(indLF)); output.peakLF = f(a + find(indLF==1, 1 ));
[~,a] = max(PSD(indHF)); output.peakHF = f(a+ find(indHF==1, 1 ));
end